Generate a comprehensive PR summary for the changes in the current feature branch, which aim to implement the following GitHub issue:
$ARGUMENTS

!git branch --show-current
!git log main..HEAD --oneline --no-decorate
!git diff main...HEAD --stat
!git diff main...HEAD --name-status

## PR Summary Generation Process

### 1. Gather Context
- Use the `gh` CLI to fetch the full issue details (title, description, acceptance criteria, labels)
- Review the git information above to understand:
  - All commits in the branch
  - Files changed and the extent of changes (additions/deletions)
  - Files added, modified, or deleted
- Read key modified files to understand the implementation approach
- Identify which project(s) are affected: `bot2/` (Python), `backend/` (Go), or both

### 2. Analyze the Changes
Review the implementation to understand:
- What problem does this solve?
- What are the key changes made?
- What new functionality was added?
- What bugs were fixed?
- What architectural or design decisions were made?
- Are there any breaking changes?
- What testing was added?

### 3. Generate PR Summary

Write a concise, informative PR summary to `PR_SUMMARY.md` in the root of the repository.

**IMPORTANT Requirements**:
- MUST include `Closes #<issue-number>` keyword (GitHub will auto-close the issue)
- Do NOT include "generated by Claude Code" or similar attribution
- Focus on WHAT changed and WHY, not HOW (code speaks for itself)
- Use clear, professional language
- Keep it concise but complete
- Organize by logical sections

#### PR Summary Format

```markdown
# [Concise PR Title - mirrors or improves issue title]

Closes #<issue-number>

## Summary
[2-4 sentence overview of what this PR accomplishes and why it's needed]

## Changes Made

### [Project Name if applicable - bot2, backend, etc.]
- [Key change 1 - focus on user-visible or architecturally significant changes]
- [Key change 2]
- [Key change 3]

[If multiple projects affected, repeat above section for each]

## Implementation Details
[Optional section - only include if there are important architectural decisions or non-obvious implementation choices that reviewers should know about]

- [Detail 1]
- [Detail 2]

## Testing
- [What tests were added or modified]
- [What scenarios are covered]
- [Any manual testing performed]

## Breaking Changes
[Only include this section if there are breaking changes]
- [Breaking change 1 and migration path]
- [Breaking change 2 and migration path]

## Additional Notes
[Optional - any other context reviewers should have, such as:]
- Dependencies added or updated
- Configuration changes required
- Known limitations or future work
- Related issues or PRs
```

#### Example PR Summary

```markdown
# Add WebSocket Bot Client Service

Closes #97

## Summary
Implements a new WebSocket-based bot client service that connects to the game server and provides a clean interface for bot implementations. This replaces the previous HTTP polling approach with real-time bidirectional communication, enabling more responsive and efficient bot behavior.

## Changes Made

### bot2/
- Added `WebSocketBotService` class in `bot/service/websocket_bot_service.py`
- Implemented connection management, heartbeat, and automatic reconnection
- Added `BotClientProtocol` for standardized bot behavior interface
- Created comprehensive unit tests in `tests/unit/service/`

## Implementation Details

- WebSocket connection uses `websockets` library with async/await patterns
- Heartbeat mechanism (30s interval) ensures connection health
- Exponential backoff retry strategy for reconnections (max 5 attempts)
- Service follows existing bot2 architectural patterns with dependency injection

## Testing
- Unit tests cover connection lifecycle, message handling, and error scenarios
- Tests use mocking for WebSocket connections to avoid external dependencies
- Added pytest markers for integration tests (requires running server)

## Additional Notes
- Requires `websockets>=12.0` dependency (added to pyproject.toml)
- Bot implementations should extend `BotClientProtocol` for compatibility
- Future work: Add authentication mechanism for production deployment
```

### 4. Review Quality

Before finalizing, ensure the PR summary:
- ✅ Includes `Closes #<issue-number>` keyword
- ✅ Does NOT include Claude Code attribution
- ✅ Is clear and concise (avoid unnecessary verbosity)
- ✅ Explains WHAT and WHY, not detailed HOW
- ✅ Highlights any breaking changes
- ✅ Mentions testing coverage
- ✅ Uses proper markdown formatting
- ✅ Is professional and ready for team review

### 5. Output to User

After writing `PR_SUMMARY.md`:
- Confirm the file location to the user
- Provide a brief 1-2 sentence summary of what the PR accomplishes
- Suggest next steps (e.g., "Review the summary in PR_SUMMARY.md, then use it when creating the PR with `gh pr create`")

## Important Notes

- **Audience**: Write for reviewers who need to understand the changes quickly
- **Brevity**: Be concise but complete—every sentence should add value
- **Context**: Assume reviewers have read the original issue but need to know what actually changed
- **Technical accuracy**: Read the actual code changes, don't just summarize the issue description
- **No fluff**: Avoid phrases like "this PR aims to" or "we decided to"—just state what was done
- **Overwrite**: Always overwrite existing `PR_SUMMARY.md` if it exists